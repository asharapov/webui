package org.echosoft.framework.ui.core;

import java.io.IOException;
import java.io.Writer;

/**
 * <b>UIContext</b> содержит как информацию о пользовательском запросе так
 * и основные методы по управлению состоянием обработки данного запроса.
 *
 * TODO:  рассмотреть возможность возврата таким вспомогательных пространств имен как Scope.JNDI, Scope.I18N
 *
 * @author Anton Sharapov
 */
public interface UIContext extends RequestContext {

    /**
     * Переключает текущую форму в менеджере состояний данного контекста. После выполнения данного вызова, методы
     * UIContext.getAttribute("XXX", Scope.STATE) будут работать с состоянием именно этой формы.
     * @param viewId  идентификатор формы с которой должна быть ассоциирован данный экземпляр контекста.
     * @param rank  ранг формы, используется в случае когда данная форма ранее отсутствовала в менеджере состояний.
     *              Влияет на то когда данное состояние должно было быть удалено из менеджера состояний.
     */
    public void switchState(String viewId, int rank);

    /**
     * Возвращает менеджер состояний ассоциированный с данным пользовательским запросом.
     * @return экземпляр {@link StateHolder}.
     */
    public StateHolder getStates();

    /**
     * Возвращает строку с префиксом который должен предварять все параметры запроса относящиеся к данному контексту. Все прочие параметры (если таковые будут)
     * будут проигнорированы. Как правило данный метод бывает актуален в портальном окружении.
     * @return  префикс для всех доступных из данного контекста параметров запроса. Если доступны абсолютно все имеющиеся параметры то метод вернет пустую строку.
     * Метод никогда не возвращает <code>null</code>. Возвращаемая строка не может начинаться и заканчиваться пробельными символами или символами табуляции.
     */
    public String getParamsPrefix();

    /**
     * Возвращает ссылку на символьный поток данных передающий данные от сервлета к клиенту.
     * @return  выходной символьный поток данных.
     * @throws IOException  в случае невозможности в рамках данного запроса воспользоваться символьным потоком. Как правило возможны две причины:
     *      Неверное указание кодировки или, что более вероятно, в соответствующем экземпляре <code>ServletResponse</code> уже вызывался метод <code>getOutputStream</code>,
     *      после которого использование символьного выходного потока становится невозможным. 
     */
    public Writer getResponseWriter() throws IOException;

}
